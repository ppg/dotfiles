" Allow switching buffers with unsaved changes in the current one
set hidden

" These make auto-complete work like it does in bash (only to the ambiguity)
set wildmenu
set wildmode=list:longest

" Status line
" The one shipped with Janus:
" statusline=%f %m %rLine:%l/%L[%p%%]Col:%vBuf:#%n[%b][0x%B]
"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]
" Useful status information at bottom of screen
set statusline=[%n]\                                    " Buffer number
set statusline+=%<%.99f\                                " File name (relative to current path)
set statusline+=%h%w%m%r%y                              " help, preview, modified, readonly, filetype

" Add in git information from fugitive
set statusline+=\ -\ %{fugitive#statusline()}
" Add in rvm ruby version
set statusline+=\ -\ %{exists('g:loaded_rvm')?rvm#statusline():''}

set statusline+=%=[\%03.3b\:\%02.2B]\ %-16(\ %l,%c\ %)  " byte value, byte value (hex), line number, column number
set statusline+=%L/%P                                   " total lines, percentage of file

"folding settings
set foldmethod=indent   " fold based on indent
set foldnestmax=5       " deepest fold levels
set foldenable          " fold by default
set foldlevel=3         " start on methods for normal class

" SYNTASTIC
let g:syntastic_aggregate_errors = 1
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = { 'mode': 'active' } ", 'passive_filetypes': ['go'] }
" Potentially enable to make vim saving go faster, but might skip go checking
" unless forced
"let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go'] }
" DEBUG
"let g:syntastic_debug=1

" Ruby
let g:syntastic_ruby_checkers = ['mri', 'rubocop']
let g:syntastic_ruby_rubocop_args = '--display-cop-names --display-style-guide'
" Stop printing out warnings for <%= some_var_here %>
let g:syntastic_eruby_ruby_quiet_messages = { 'regex': 'possibly useless use of a variable in void context' }

" Go
" Enable goimports to automatically insert import paths
let g:go_fmt_command = "goimports"
let g:syntastic_go_checkers = ['go', 'gofmt', 'golint', 'govet', 'errcheck']
let g:syntastic_go_go_test_args = "-tags 'acceptance benchmark integration'"
let g:syntastic_go_go_build_args = "-tags 'acceptance benchmark integration'"

" JavaScript
let g:syntastic_javascript_checkers = ['jshint', 'eslint']
" TODO(ppg): don't use ctrl-f, use for forward by page
"autocmd FileType javascript vnoremap <buffer> <c-f> :call RangeJsBeautify()<cr>
"autocmd FileType json vnoremap <buffer> <c-f> :call RangeJsonBeautify()<cr>
"autocmd FileType jsx vnoremap <buffer> <c-f> :call RangeJsxBeautify()<cr>
"autocmd FileType html vnoremap <buffer> <c-f> :call RangeHtmlBeautify()<cr>
"autocmd FileType css vnoremap <buffer> <c-f> :call RangeCSSBeautify()<cr>

" API Blueprint
" Fix ctrl-b to be back still
autocmd FileType apiblueprint nnoremap <C-b> <S-Up>

" Override filetypes
au BufRead,BufNewFile Dockerfile.* set filetype=dockerfile
au BufRead,BufNewFile .eslintrc set filetype=json

" Highlight trailing whitespace, and remove automatically on save
" TODO Look for a plugin for this
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()
function! TrimWhiteSpace()
  %s/\s\+$//e
endfunction
autocmd BufWritePre * :call TrimWhiteSpace()

" Override *.ino to be Arduino files
au BufRead,BufNewFile *.ino set filetype=cpp

" Define common tabularizations
if exists(":Tabularize")
  nmap <Leader>a= :Tabularize /=<CR>
  vmap <Leader>a= :Tabularize /=<CR>
  nmap <Leader>a: :Tabularize /:\zs<CR>
  vmap <Leader>a: :Tabularize /:\zs<CR>
  nmap <Leader>a, :Tabularize /,\zs<CR>
  vmap <Leader>a, :Tabularize /,\zs<CR>
endif
" TODO Probably put these in after insert too like cucumber?

" Tabularize cucumber after insert
inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction
